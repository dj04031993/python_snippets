"""
Banking Account Creation Event Generator
Generates test data for account creation events with fixed combinations from CSV
"""

import csv
import json
import random
import string
import uuid
from datetime import datetime, timedelta, timezone
from pathlib import Path
from itertools import cycle
from typing import List, Dict, Any

# ============================================================================
# HARDCODED CONFIGURATION LISTS
# ============================================================================

FULL_NAMES = [
    "Rajesh Kumar", "Priya Sharma", "Amit Patel", "Anjali Gupta", "Vikram Singh",
    "Neha Reddy", "Suresh Nair", "Kavita Desai", "Arjun Mehta", "Deepa Iyer",
    "Rohit Verma", "Swati Joshi", "Karthik Rao", "Pooja Agarwal", "Manish Chopra",
    "Shreya Bansal", "Aditya Khanna", "Ritu Malhotra", "Sanjay Bhatt", "Meera Pillai",
    "Nikhil Saxena", "Anita Bose", "Gaurav Mishra", "Divya Naidu", "Prasad Hegde",
    "Lakshmi Menon", "Rahul Tiwari", "Sunita Pandey", "Varun Kapoor", "Geeta Sinha"
]

IFSC_CODES = [
    "ICIC0001234", "ICIC0005678", "ICIC0009012", "ICIC0003456", "ICIC0007890",
    "SBIN0001111", "SBIN0002222", "SBIN0003333", "SBIN0004444", "SBIN0005555",
    "HDFC0001234", "HDFC0005678", "HDFC0009012", "HDFC0003456", "HDFC0007890",
    "AXIS0001234", "AXIS0005678", "AXIS0009012", "AXIS0003456", "AXIS0007890",
    "KOTAK001234", "KOTAK005678", "YES0001234", "IDBI0001234", "PNB0001234"
]

INITIAL_DEPOSITS = [
    1000, 2500, 5000, 10000, 15000, 20000, 25000, 30000,
    50000, 75000, 100000, 150000, 200000, 250000, 500000
]

ACCOUNT_TYPES = ["SAVINGS", "CURRENT", "SALARY", "NRE", "NRO"]

# Hardcoded paths
CSV_PATH = "L:\TEST\config.csv"
OUTPUT_DIR = "output"

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def generate_customer_id() -> str:
    """Generate a random customer ID in format C + 9 digits"""
    digits = ''.join(random.choices(string.digits, k=9))
    return f"C{digits}"

def generate_account_number() -> str:
    """Generate a random 16-digit alphanumeric account number"""
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=16))

def generate_date_of_birth() -> str:
    """Generate a random date of birth for someone aged 18-100 years"""
    today = datetime.now()
    min_age = 18
    max_age = 100
    
    # Calculate the date range
    max_birth_date = today - timedelta(days=min_age * 365)
    min_birth_date = today - timedelta(days=max_age * 365)
    
    # Generate random date in range
    days_between = (max_birth_date - min_birth_date).days
    random_days = random.randint(0, days_between)
    birth_date = min_birth_date + timedelta(days=random_days)
    
    return birth_date.strftime("%Y-%m-%d")

def get_current_timestamp() -> str:
    """Get current timestamp in ISO-8601 format with IST timezone (+05:30)"""
    ist_offset = timezone(timedelta(hours=5, minutes=30))
    current_time = datetime.now(ist_offset)
    return current_time.isoformat()

def load_combinations(file_path: str) -> List[Dict[str, str]]:
    """Load combinations from CSV file"""
    combinations = []
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            for row in reader:
                combinations.append(row)
        return combinations
    except FileNotFoundError:
        print(f"Error: CSV file not found at {file_path}")
        print("Please ensure config/combinations.csv exists with the following columns:")
        print("clientGroup,clientId,system,prin,agent")
        exit(1)
    except Exception as e:
        print(f"Error reading CSV file: {e}")
        exit(1)

def get_unique_client_groups(combinations: List[Dict[str, str]]) -> List[str]:
    """Extract unique clientGroups from combinations"""
    return sorted(list(set(combo['clientGroup'] for combo in combinations)))

def filter_combinations_by_group(combinations: List[Dict[str, str]], client_group: str) -> List[Dict[str, str]]:
    """Filter combinations by clientGroup"""
    if client_group.upper() == 'ALL':
        return combinations
    return [combo for combo in combinations if combo['clientGroup'] == client_group]

def generate_record(combination: Dict[str, str]) -> Dict[str, Any]:
    """Generate a single record with the given combination"""
    return {
        "message_type": "bank_account_created",
        "event_id": str(uuid.uuid4()),
        "event_timestamp": get_current_timestamp(),
        "customer_id": generate_customer_id(),
        "full_name": random.choice(FULL_NAMES),
        "date_of_birth": generate_date_of_birth(),
        "account_number": generate_account_number(),
        "account_type": random.choice(ACCOUNT_TYPES),
        "ifsc": random.choice(IFSC_CODES),
        "initial_deposit": random.choice(INITIAL_DEPOSITS),
        "clientGroup": combination['clientGroup'],
        "clientId": combination['clientId'],
        "system": combination['system'],
        "prin": combination['prin'],
        "agent": combination['agent']
    }

def generate_records(combinations: List[Dict[str, str]], count: int) -> List[Dict[str, Any]]:
    """Generate specified number of records using round-robin for combinations"""
    if not combinations:
        print("Error: No combinations available for the selected clientGroup")
        return []
    
    records = []
    # Create a cycle iterator for round-robin
    combo_cycle = cycle(combinations)
    
    for _ in range(count):
        combination = next(combo_cycle)
        records.append(generate_record(combination))
    
    return records

def save_records(records: List[Dict[str, Any]], client_group: str) -> str:
    """Save records to JSONL file"""
    # Create output directory if it doesn't exist
    Path(OUTPUT_DIR).mkdir(exist_ok=True)
    
    # Generate filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{client_group}_records_{timestamp}.jsonl"
    filepath = Path(OUTPUT_DIR) / filename
    
    # Write records as JSONL
    with open(filepath, 'w', encoding='utf-8') as file:
        for record in records:
            json.dump(record, file, ensure_ascii=False)
            file.write('\n')
    
    return str(filepath)

def get_user_input(combinations: List[Dict[str, str]]) -> tuple:
    """Get user input for clientGroup and record count"""
    unique_groups = get_unique_client_groups(combinations)
    
    print("\n" + "="*60)
    print("BANKING ACCOUNT CREATION EVENT GENERATOR")
    print("="*60)
    
    # Display available client groups
    print("\nAvailable Client Groups:")
    for group in unique_groups:
        combo_count = len([c for c in combinations if c['clientGroup'] == group])
        print(f"  - {group} ({combo_count} combinations)")
    print("  - ALL (generate for all groups)")
    
    # Get client group selection
    while True:
        print("\n1. Select clientGroup [Enter specific name or 'ALL']:")
        client_group = input("   > ").strip()
        
        if client_group.upper() == 'ALL' or client_group in unique_groups:
            break
        else:
            print(f"   Error: '{client_group}' not found. Please choose from the list above.")
    
    # Get record count
    while True:
        print("\n2. Enter number of records to generate:")
        try:
            count = int(input("   > ").strip())
            if count > 0:
                break
            else:
                print("   Error: Please enter a positive number.")
        except ValueError:
            print("   Error: Please enter a valid number.")
    
    return client_group, count

def display_summary(client_group: str, count: int, combinations: List[Dict[str, str]]):
    """Display generation summary before processing"""
    print("\n" + "-"*60)
    print("GENERATION SUMMARY")
    print("-"*60)
    print(f"Client Group: {client_group}")
    print(f"Records to Generate: {count:,}")
    print(f"Available Combinations: {len(combinations)}")
    
    if len(combinations) > 0:
        records_per_combo = count // len(combinations)
        remainder = count % len(combinations)
        print(f"Distribution: ~{records_per_combo} records per combination")
        if remainder > 0:
            print(f"             (first {remainder} combinations get 1 extra record)")
    
    print("-"*60)

def main():
    """Main execution function"""
    try:
        # Load combinations from CSV
        print("\nLoading combinations from config/combinations.csv...")
        all_combinations = load_combinations(CSV_PATH)
        
        if not all_combinations:
            print("Error: No combinations found in CSV file")
            return
        
        print(f"Loaded {len(all_combinations)} total combinations")
        
        # Get user input
        client_group, record_count = get_user_input(all_combinations)
        
        # Filter combinations based on selection
        filtered_combinations = filter_combinations_by_group(all_combinations, client_group)
        
        if not filtered_combinations:
            print(f"\nError: No combinations found for clientGroup '{client_group}'")
            return
        
        # Display summary
        display_summary(client_group, record_count, filtered_combinations)
        
        # Generate records
        print("\nGenerating records...")
        records = generate_records(filtered_combinations, record_count)
        
        # Save records
        output_file = save_records(records, client_group)
        
        # Final summary
        print("\n" + "="*60)
        print("GENERATION COMPLETE")
        print("="*60)
        print(f"✓ Generated: {len(records):,} records")
        print(f"✓ Output File: {output_file}")
        print(f"✓ File Size: {Path(output_file).stat().st_size / 1024:.2f} KB")
        print("="*60)
        
        # Show sample record
        print("\nSample Record (first record in file):")
        print("-"*60)
        print(json.dumps(records[0], indent=2))
        
    except KeyboardInterrupt:
        print("\n\nOperation cancelled by user.")
    except Exception as e:
        print(f"\nUnexpected error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
